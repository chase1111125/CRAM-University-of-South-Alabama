# -*- coding: utf-8 -*-
"""Final_Data_Script.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14qQ019WlW8IEMyv2u_Y4NWOBIs0TlSFn
"""

!pip install python-docx
!pip install pdfplumber

import numpy as np
from PIL import Image
import os
import zipfile
from docx import Document
import pdfplumber  # For handling PDF files
import matplotlib.pyplot as plt
from collections import Counter
from scipy.stats import entropy as kl_entropy

# Define the 256-color ANSI palette
def generate_ansi_palette():
    """ Generate the 256-color ANSI palette (16 basic colors + 6x6x6 color cube + grayscale). """
    palette = []  # Holds the ANSI colors

    # Basic colors (0-15)
    basic_colors = [
        (0, 0, 0),         # 0: Black
        (255, 0, 0),       # 1: Red
        (0, 255, 0),       # 2: Green
        (255, 255, 0),     # 3: Yellow
        (0, 0, 255),       # 4: Blue
        (255, 0, 255),     # 5: Magenta
        (0, 255, 255),     # 6: Cyan
        (255, 255, 255),   # 7: White
        (128, 128, 128),   # 8: Gray
        (255, 102, 102),   # 9: Light Red
        (102, 255, 102),   # 10: Light Green
        (255, 255, 102),   # 11: Light Yellow
        (102, 102, 255),   # 12: Light Blue
        (255, 102, 255),   # 13: Light Magenta
        (102, 255, 255),   # 14: Light Cyan
        (255, 255, 255)    # 15: Bright White
    ]

    # Add the 216 colors from the 6x6x6 color cube
    for r in range(6):
        for g in range(6):
            for b in range(6):
                palette.append((r * 51, g * 51, b * 51))  # 51 is used to create even spacing

    # Grayscale colors (232-255)
    for i in range(24):
        gray_value = int(8 + i * 10)  # Grayscale values range from 8 to 255
        palette.append((gray_value, gray_value, gray_value))

    return palette

# ANSI color palette
ANSI_PALETTE = generate_ansi_palette()

def rgb_distance(rgb1, rgb2):
    """
    Compute the Euclidean distance between two RGB colors.
    """
    return np.sqrt((rgb1[0] - rgb2[0]) ** 2 + (rgb1[1] - rgb2[1]) ** 2 + (rgb1[2] - rgb2[2]) ** 2)

def closest_ansi_color(rgb):
    """
    Find the closest ANSI color to the given RGB value by comparing Euclidean distance.
    """
    min_distance = float('inf')
    closest_color = 0
    for i, color in enumerate(ANSI_PALETTE):
        distance = rgb_distance(rgb, color)
        if distance < min_distance:
            min_distance = distance
            closest_color = i
    return closest_color

def text_to_colorized_output(input_text, width=1000):
    """ Convert text input to a colorized output using the ANSI palette. """
    # Convert text to a list of RGB values
    output_img = np.zeros((len(input_text), width, 3), dtype=np.uint8)

    # Create color-mapped output based on character codes
    for i, char in enumerate(input_text):
        # Skip spaces (or any other condition you want)
        char_code = ord(char)
        color_index = char_code % len(ANSI_PALETTE)
        output_img[i % len(input_text), i % width] = ANSI_PALETTE[color_index]

    return output_img

def handle_binary_data(input_data, width=1000):
    """ Convert binary data to colorized output based on hex values. """
    # Create an empty image (height x width x 3 for RGB colors)
    output_img = np.zeros((len(input_data) // width + 1, width, 3), dtype=np.uint8)

    hex_values = [f"{byte:02x}" for byte in input_data]  # Create hex values for each byte

    for i, hex_value in enumerate(hex_values):
        # Colorize based on the hex value
        color_index = int(hex_value, 16) % len(ANSI_PALETTE)
        output_img[i // width, i % width] = ANSI_PALETTE[color_index]

    return output_img

def extract_text_from_docx(docx_file_path):
    """ Extract text from a .docx file. """
    doc = Document(docx_file_path)
    text = "\n".join([paragraph.text for paragraph in doc.paragraphs])
    return text

def extract_text_from_pdf(pdf_file_path):
    """ Extract text from a .pdf file using pdfplumber. """
    text = ""
    with pdfplumber.open(pdf_file_path) as pdf:
        for page in pdf.pages:
            text += page.extract_text()
    return text

def generate_ansi_color_output(input_file_path, output_file_path):
    """ Generate colorized output (text or binary) based on the input file type. """
    # Try reading the file as text first
    try:
        if input_file_path.endswith('.docx'):
            # Extract text from .docx files
            input_text = extract_text_from_docx(input_file_path)
        elif input_file_path.endswith('.pdf'):
            # Extract text from .pdf files
            input_text = extract_text_from_pdf(input_file_path)
        else:
            with open(input_file_path, 'r', encoding='utf-8') as file:
                input_text = file.read()

        # Convert text to ANSI color representation
        output_img = text_to_colorized_output(input_text)

    except UnicodeDecodeError:
        # If a UnicodeDecodeError occurs, treat the file as binary
        print(f"Cannot decode {input_file_path} as UTF-8. Treating it as binary data.")
        with open(input_file_path, 'rb') as file:
            input_data = file.read()

        # Convert binary data to ANSI color representation (using hex dump)
        output_img = handle_binary_data(input_data)

    # Calculate the entropy of the entire image
    entropy = calculate_entropy(output_img)
    print(f"Entropy of the entire image: {entropy:.4f}")

    # Save the generated image as a PNG file
    output_image = Image.fromarray(output_img)
    output_image.save(output_file_path)
    print(f"Colorized output saved as {output_file_path}")

def calculate_entropy(image):
    """ Calculate the entropy of the entire image. """
    # Convert the image to grayscale to simplify the entropy calculation
    gray_image = np.mean(image, axis=2).astype(np.uint8)

    # Calculate the histogram of the grayscale image
    histogram, _ = np.histogram(gray_image, bins=256, range=(0, 256))
    histogram = histogram / histogram.sum()  # Normalize the histogram
    histogram = histogram[histogram > 0]  # Avoid log(0)

    # Return the entropy
    return -np.sum(histogram * np.log2(histogram))

def process_zip(zip_file_path, output_dir="output_images"):
    """ Extract and process each file in the zip archive. """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Open the zip file and process its contents
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        zip_ref.extractall(output_dir)
        file_list = zip_ref.namelist()
        print(f"Extracted {len(file_list)} files from {zip_file_path}")

        # For each file in the zip, generate the colorized output
        for file_name in file_list:
            # Construct the full path for the extracted file
            input_file_path = os.path.join(output_dir, file_name)

            # Check if the current entry is a file (not a directory)
            if os.path.isdir(input_file_path):
                print(f"Skipping directory: {input_file_path}")
                continue  # Skip directories

            # Generate colorized output image
            output_file_path = os.path.join(output_dir, f"{os.path.splitext(file_name)[0]}_colorized.png")
            print(f"Processing {input_file_path}...")
            generate_ansi_color_output(input_file_path, output_file_path)

def main():
    # Input the zip file path or a single file
    input_path = input("Enter the path of the zip file or a single file (text, .docx, .pdf, or binary): ")

    if not os.path.exists(input_path):
        print(f"File not found at {input_path}. Please provide a valid path.")
        return

    if zipfile.is_zipfile(input_path):
        # Process zip file
        process_zip(input_path)
    else:
        # Process a single file (either text, .docx, .pdf, or binary)
        output_dir = "output_images"
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Get the base name for the output image
        output_file_path = os.path.join(output_dir, f"{os.path.splitext(os.path.basename(input_path))[0]}_colorized.png")
        generate_ansi_color_output(input_path, output_file_path)

if __name__ == "__main__":
    main()